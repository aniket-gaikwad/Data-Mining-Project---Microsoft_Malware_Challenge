#!/usr/bin/python
from multiprocessing import Pool
import re
import os
from os.path import isfile, join
import time
import sys
from collections import OrderedDict

# Declaring all dictionaries
mypath='/home/aniket/MicrosoftMalware/Sample/mix/'
#mypath='/N/dc2/scratch/hydargah/dm/trainRaw/'
#trainLabelsFile='/N/dc2/scratch/hydargah/dm/trainLabels.csv'
trainLabelsFile='/home/aniket/MicrosoftMalware/trainLabels.csv'
instructionOpcodeDict=OrderedDict()
instructionOpcodeDict={"ADD":0,
"PUSH":0,
"POP":0,
"OR":0,
"TWOBYTE":0,
"ADC":0,
"SBB":0,
"AND":0,
"ES:":0,
"DAA":0,
"SUB":0,
"CS:":0,
"DAS":0,
"XOR":0,
"SS:":0,
"AAA":0,
"CMP":0,
"DS:":0,
"AAS":0,
"INC":0,
"DEC":0,
"PUSH":0,
"POP":0,
"PUSHA":0,
"POPA":0,
"BOUND":0,
"ARPL":0,
"FS:":0,
"GS:":0,
"OPSIZE:":0,
"ADSIZE:":0,
"IMUL":0,
"INSB":0,
"INSW":0,
"OUTSB":0,
"OUTSW":0,
"JO":0,
"JNO":0,
"JB":0,
"JNB":0,
"JZ":0,
"JNZ":0,
"JBE":0,
"JA":0,
"JS":0,
"JNS":0,
"JP":0,
"JNP":0,
"JL":0,
"JNL":0,
"JLE":0,
"JNLE":0,
"TEST":0,
"XCHG":0,
"LEA":0,
"NOP":0,
"CBW":0,
"CWD":0,
"CALL":0,
"WAIT":0,
"PUSHF":0,
"POPF":0,
"SAHF":0,
"LAHF":0,
"MOVSB":0,
"MOVSW":0,
"CMPSB":0,
"CMPSW":0,
"STOSB":0,
"STOSW":0,
"LODSB":0,
"LODSW":0,
"SCASB":0,
"SCASW":0,
"#2":0,
"RETN":0,
"LES":0,
"LDS":0,
"ENTER":0,
"LEAVE":0,
"RETF":0,
"INT3":0,
"INT":0,
"INTO":0,
"IRET":0,
"AAM":0,
"AAD":0,
"SALC":0,
"XLAT":0,
"ESC":0,
"LOOPNZ":0,
"LOOPZ":0,
"LOOP":0,
"JCXZ":0,
"IN":0,
"OUT":0,
"CALL":0,
"JMP":0,
"LOCK:":0,
"INT1":0,
"REPNE:":0,
"REP:":0,
"HLT":0,
"CMC":0,
"#3":0,
"CLC":0,
"STC":0,
"CLI":0,
"STI":0,
"CLD":0,
"STD":0,
"#4":0,
"#5":0
}
segmentDict=OrderedDict()
segmentDict={".IDATA":0,
             ".RDATA":0,
             ".DATA":0,
             ".TEXT":0}
systemCallDictionary=OrderedDict()
#systemCallDictionary={}
fileLabelDictionary=OrderedDict()
#fileLabelDictionary={}


def populateSystemCallFeatures(ffile):
	fileName=mypath+ffile
	print(fileName)
	#global systemCallDictionary,instructionOpcodeDict,segmentDict
	fileContent=[]
	fileContentWithoutComments=[]
	#This will store all the system calls
	systemCallList=[]                           

	with open(fileName) as f:
		for line in f:
			content=line.split()        
			# First word is the Segment_name : Memory_Address
			# Extract just a Segment_Name
			segmentName=content[0].split(':')
			key=segmentName[0].upper()
		
			if(key==".TEXT"):
				fileContent.append(content)
				#print(content)

	#Read contents of file stored in the List
	#And remove the COMMENTS from file

	for entry in fileContent:
		restOfEntry=[]
		for subEntry in entry:
			if(subEntry==';'):
				break;
			restOfEntry.append(subEntry)
		#print(restOfEntry)
		fileContentWithoutComments.append(restOfEntry)	

	#Reading contents of file without comments : "fileContentWithoutComments"

		
	for entry in fileContentWithoutComments:
		for subEntry in entry:
			if(re.match('[_]',subEntry)):
				key=subEntry.upper()
				key=key.replace(',','')
				systemCallList.append(key)

	return systemCallList

def populateFeatures(ffile):
	fileName=mypath+ffile
	fileContent=[]
	fileContentWithoutComments=[]
	ListOfDictionaries=[]
	tempsegmentDict=segmentDict.copy()
	tempsystemCallDictionary=systemCallDictionary.copy()
	tempinstructionOpcodeDict=instructionOpcodeDict.copy()

	with open(fileName) as f:
		for line in f:
			content=line.split()        
			# First word is the Segment_name : Memory_Address
			# Extract just a Segment_Name
			segmentName=content[0].split(':')
			key=segmentName[0].upper()
			key=key.replace(',','')

			if(key in tempsegmentDict):
				tempsegmentDict[key]=tempsegmentDict[key]+1
			
		
			if(key==".TEXT"):
				fileContent.append(content)
				#print(content)


#Read contents of file stored in the List
#And remove the COMMENTS from file

	for entry in fileContent:
		restOfEntry=[]
		for subEntry in entry:
			if(subEntry==';'):
				break;
			restOfEntry.append(subEntry)
		#print(restOfEntry)
		fileContentWithoutComments.append(restOfEntry)	

#Reading contents of file without comments : "fileContentWithoutComments"

	for entry in fileContentWithoutComments:
		for subEntry in entry:
			if(re.match('[_]',subEntry)):
				key=subEntry.upper()
				key=key.replace(',','')
				if(key in tempsystemCallDictionary):
					tempsystemCallDictionary[key]=tempsystemCallDictionary[key]+1
			#print(subEntry)

		#Check for OPCODE
			key=subEntry.upper()
			key=key.replace(',','')
			if(key in tempinstructionOpcodeDict):
				tempinstructionOpcodeDict[key]=tempinstructionOpcodeDict[key]+1

	fileName=ffile.upper()
	if(fileName in fileLabelDictionary):
		label=fileLabelDictionary[fileName]
	else:
		print(" *********** ERROR **************** : No class label found for file : "+fileName)

	ListOfDictionaries.append(ffile)			
	ListOfDictionaries.append(tempsegmentDict)
	ListOfDictionaries.append(tempinstructionOpcodeDict)
	ListOfDictionaries.append(tempsystemCallDictionary)
	ListOfDictionaries.append(label)
	return ListOfDictionaries

def flushAllDictionaries():
	global systemCallDictionary,instructionOpcodeDict,segmentDict	
	d1 = {key: 0 for key in systemCallDictionary}
	d2 = {key: 0 for key in instructionOpcodeDict}
	d3 = {key: 0 for key in segmentDict}

	systemCallDictionary=d1
	instructionOpcodeDict=d2
	segmentDict=d3

def populatefileLabelDictionary(inputFile):
	global fileLabelDictionary
	with open(inputFile) as f:
		for line in f:
			content=line.split(',')
			key=content[0].upper()
			key=key.replace('"','')
			key=key+".ASM"
			value=content[1]
			if(key in fileLabelDictionary):
				print("Duplicate File Name : "+key)
			else:
				fileLabelDictionary[key]=value

    #Commentiing the printing of files and labels as its working good
	#for key in fileLabelDictionary:
		#print("File name : "+ str(key) +" Label : "+fileLabelDictionary[key])

def printAllFeatures():
	#Printing			
	dummyCount=0
	global systemCallDictionary  #,instructionOpcodeDict,segmentDict
	print("_________________SYSTEM CALLS________________________________")
	for key in systemCallDictionary:
		if(systemCallDictionary[key]>0):
			print("Key : "+key+"  "+"Value : "+str(systemCallDictionary[key]))
			dummyCount+=1
	print("---------- Count -----------"+str(dummyCount))

	#Print contents of the dictionary which
	#contains length of the each Segment in the file
	#print("____________________SIZE OF SEGMENTS____________________________________")
	#for key in segmentDict:
	#	print("Key : "+key+"  "+"Value : "+str(segmentDict[key]))


	#print("_______________________OPCODE___________________________")
	#for key in instructionOpcodeDict:
	#	print("Key : "+key+"  "+"Value : "+str(instructionOpcodeDict[key]))

def generateHeader():
	global systemCallDictionary,instructionOpcodeDict,segmentDict
	
	# Writting header to outfile
	header="fileName"
	cnt=1
	for key in segmentDict:
		header=header+","+key
		cnt+=1
	for key in instructionOpcodeDict:
		header=header+","+key
		cnt+=1	
	for key in systemCallDictionary:
		header=header+","+key
		cnt+=1
	
	header=header+","+"classLabel"+"\n"
	with open('features.csv', 'w') as the_file:
		the_file.write(header) 	
 	print("Number of features : "+str(cnt))

def generateFeatures(returnedList):
	for listofFeatures in returnedList:
		flag=0
		data=""
		for feature in listofFeatures:
			if isinstance(feature,str):
				if flag==0:
					print("File : "+feature)
					data=data+feature
					flag=1
				else:
					print("Label : "+feature)
					data=data+","+feature
					flag=0
			else:
				if flag==1:	
					flag=2
					if isinstance(feature,dict):
						print("************* Segment Dictionary ***************************")
						for key in feature:
							print("Key : "+key+" -> "+"Value : "+str(feature[key]))
							data=data+","+str(feature[key])
				else:
					if flag==2:
						flag=3
						if isinstance(feature,dict):
							print("************* Opcode Dictionary ***************************")
							for key in feature:
								print("Key : "+key+" -> "+"Value : "+str(feature[key]))
								data=data+","+str(feature[key])
					else:
						if flag==3:
							flag=4
							if isinstance(feature,dict):
								print("************* SYScall Dictionary ***************************")
								for key in feature:
									print("Key : "+key+" -> "+"Value : "+str(feature[key]))
									data=data+","+str(feature[key])
		with open('features.csv', 'a') as the_file:
			the_file.write(data) 	
	#print("File : "+fileName+" ,"+"Number of features : "+str(cnt))



def main():
	print("______________________POPULATE TRAINFILE LABEL START_________________________")
	populatefileLabelDictionary(trainLabelsFile)
	print("______________________POPULATE TRAINFILE LABEL ENDS___________________________")
	
	onlyfiles = [ f for f in os.listdir(mypath) if ".asm" in f]
	print("______________________SYSTEM_CALLS EXTRACTION STARTS________________________")
	p = Pool(32)
	returnedList=p.map(populateSystemCallFeatures,onlyfiles)
	p.close()
	p.join()		
	print("_____________________ PROCESSING OUTPUT OF MAP FUNCTION FOR SYSTEM_CALLS EXTRACTION STARTS______________________")
	for list in returnedList:
		for item in list:
			if item in systemCallDictionary:
				systemCallDictionary[item]=systemCallDictionary[item]+1
			else:
				systemCallDictionary[item]=1
	print("_____________________ PROCESSING OUTPUT OF MAP FUNCTION FOR SYSTEM_CALLS EXTRACTION ENDS______________________")
	print("______________________SYSTEM CALLS EXTRACTION ENDS________________________")
	
	print("_____________________FEATURE EXTRACTION STARTS______________________________")
	flushAllDictionaries()
	p = Pool(32)
	returnedList=p.map(populateFeatures,onlyfiles)
	p.close()
	p.join()
	print("_____________________ PROCESSING OUTPUT OF MAP FUNCTION FOR FEATURE_EXTRACTION STARTS______________________")
	generateHeader()
	generateFeatures(returnedList)
	print("_____________________ PROCESSING OUTPUT OF MAP FUNCTION FOR FEATURE_EXTRACTION ENDS______________________")
	print("_____________________FEATURE EXTRACTION ENDS________________________________")
				
	#printAllFeatures()

if __name__ == "__main__": 
	#Rediecting all output to file
	orig_stdout=sys.stdout
	f=file('out.txt','w')
	sys.stdout=f

	#print path
	start = time.asctime(time.localtime(time.time()))
	print("Start Time : "+start)
	main()
	end = time.asctime(time.localtime(time.time()))
	print("End Time : "+end)
	#print(str(time.time() - start)