#!/usr/bin/python
import itertools
import functools
from multiprocessing import Pool
import re
import os
from os.path import isfile, join
import time
import sys
import gc
from collections import OrderedDict
#import libarchive.public
import pandas as pd
import numpy as np
from multiprocessing import  JoinableQueue, Queue

# Declaring all dictionaries
#mypath='/home/aniket/MicrosoftMalware/Sample/Test1/'
#mypath='/N/dc2/scratch/hydargah/dm/testRaw/'

featureDict=OrderedDict()
# Big Red II Parameters
trainFile='/N/dc2/scratch/anikgaik/dm/features.csv'
path='/N/dc2/scratch/hydargah/dm/testRaw/'
path1='/N/dc2/scratch/anikgaik/dm/dummytest1/'
path2='/N/dc2/scratch/anikgaik/dm/dummytest2/'
path3='/N/dc2/scratch/anikgaik/dm/dummytest3/'
path4='/N/dc2/scratch/anikgaik/dm/dummytest4/'
# Local Machine Parameters
#trainFile='features.csv'
#path='/home/aniket/MicrosoftMalware/Sample/Test1/'
#path1='/home/aniket/MicrosoftMalware/Sample/Test2/'
#path2='/home/aniket/MicrosoftMalware/Sample/Test3/'
#path3='/home/aniket/MicrosoftMalware/Sample/Test4/'
#path4='/home/aniket/MicrosoftMalware/Sample/Test5/'


def populateFeatureNames(ffile):
	global featureDict
	fileName=ffile
	#print(fileName)

	f=open(fileName)
	line=f.readline()
	#Read just header from train file to get all features chosen
	content=line.split(',')
	content=content[1:len(content)-1]        
	for key in content:
		featureDict[key]=0
	f.close()
	del line,content,fileName
	gc.collect()
	
def populateFeatures((q_in,q_out)):
	global featureDict
	(ffile,filePath)=q_in.get()
	fileName=filePath+ffile
	print("File Name : "+fileName)
	fileContent=[]
	fileContentWithoutComments=[]
	ListOfDictionaries=[]
	tempfeatureDict=featureDict.copy()

	f=open(fileName)
	for line in iter(f):
		content=line.split()        
		# First word is the Segment_name : Memory_Address
		# Extract just a Segment_Name
		segmentName=content[0].split(':')
		key=segmentName[0].upper()
		key=key.replace(',','')

		if(key in tempfeatureDict):
			tempfeatureDict[key]=tempfeatureDict[key]+1
			
		
		if(key==".TEXT"):
			fileContent.append(content)
			#print(content)
	f.close()

#Read contents of file stored in the List
#And remove the COMMENTS from file
	if not fileContent:
		print("NO .TXT section in ASM File")
		ListOfDictionaries.append(ffile)
		ListOfDictionaries.append(tempfeatureDict)
		return ListOfDictionaries

	for entry in fileContent:
		restOfEntry=[]
		for subEntry in entry:
			if(subEntry==';'):
				break;
			restOfEntry.append(subEntry)
		#print(restOfEntry)
		fileContentWithoutComments.append(restOfEntry)	
	del fileContent
#Reading contents of file without comments : "fileContentWithoutComments"

	for entry in fileContentWithoutComments:
		for subEntry in entry:
			if(re.match('[_]',subEntry)):
				key=subEntry.upper()
				key=key.replace(',','')
				if(key in tempfeatureDict):
					tempfeatureDict[key]=tempfeatureDict[key]+1
			#print(subEntry)

		#Check for OPCODE
			key=subEntry.upper()
			key=key.replace(',','')
			if(key in tempfeatureDict):
				tempfeatureDict[key]=tempfeatureDict[key]+1

	fileName=ffile.upper()
	
	ListOfDictionaries.append(ffile)			
	ListOfDictionaries.append(tempfeatureDict)
	del fileContentWithoutComments
	# del ListOfDictionaries
	del tempfeatureDict
	del restOfEntry
	del content
	gc.collect()

	q_out.put(ListOfDictionaries)
	q_in.task_done()

 
def printAllFeatures():
	#Printing			
	dummyCount=0
	global tempfeatureDict
	print("_________________SYSTEM CALLS________________________________")
	for key in tempfeatureDict:
		if(tempfeatureDict[key]>0):
			#print("Key : "+key+"  "+"Value : "+str(tempfeatureDict[key]))
			dummyCount+=1
	#print("---------- Count -----------"+str(dummyCount))

	#Print contents of the dictionary which
	#contains length of the each Segment in the file
	#print("____________________SIZE OF SEGMENTS____________________________________")
	#for key in segmentDict:
	#	print("Key : "+key+"  "+"Value : "+str(segmentDict[key]))


	#print("_______________________OPCODE___________________________")
	#for key in instructionOpcodeDict:
	#	print("Key : "+key+"  "+"Value : "+str(instructionOpcodeDict[key]))

def generateHeader():
	global featureDict
	
	# Writting header to outfile
	header=""
	cnt=0
	for key in featureDict:
		if cnt==0:
			header="fileName"+","+key
		else:
			header=header+","+key
		cnt+=1
	
	with open('test1.csv', 'w') as the_file:
		the_file.write(header) 	
 	print("Number of features : "+str(cnt))
	gc.collect()

def generateFeatures(returnedList):
	for listofFeatures in returnedList:
		flag=0
		data="\n"
		for feature in listofFeatures:
			if isinstance(feature,str):
				#print("File : "+feature)
				data=data+feature
			else:
				if isinstance(feature,dict):
					print("************* featureDict Dictionary ***************************")
					for key in feature:
						#print("Key : "+key+" -> "+"Value : "+str(feature[key]))
						data=data+","+str(feature[key])
				 
		with open('test1.csv', 'a') as the_file:
			the_file.write(data) 	
	#print("File : "+fileName+" ,"+"Number of features : "+str(cnt))
	gc.collect()



def main():
	print("______POPULATE FEATURE NAMES START__")
	populateFeatureNames(trainFile)
	print("___POPULATE FEATURE NAMES ENDS__")
	
	################
	q = JoinableQueue(20)
	q_feats = Queue()
	pool = Pool(6,populateFeatures, ((q, q_feats),))	
	returnedList=[]
	print("__onlyfile population starts__")
	onlyfiles = [ f for f in os.listdir(path) if ".asm" in f]
	print("___FEATURE EXTRACTION STARTS FOR PATH__")
	for ffile in onlyfiles:
		q.put((ffile,path),True)
	q.close()
	#time.sleep(100)
	q.join()
	#time.sleep(100)
	pool.close()
	
	for i in range(q_feats.qsize()):
		returnedList.append(q_feats.get())
	#returnedList=p.map(functools.partial(populateFeatures, filePath=path), onlyfiles)
	#time.sleep(10)
	#p.close()
	#time.sleep(100)
	#p.join()
	#time.sleep(10)
	print("___ PROCESSING OUTPUT OF MAP FUNCTION FOR FEATURE_EXTRACTION STARTS___")
	#except:
	#	print("Something went wrong")
	generateHeader()
	generateFeatures(returnedList)
	
	print("_____ PROCESSING OUTPUT OF MAP FUNCTION FOR FEATURE_EXTRACTION ENDS____")
	print("_____FEATURE EXTRACTION ENDS____")
				
	#printAllFeatures()

if __name__ == "__main__": 
	#Rediecting all output to file
	orig_stdout=sys.stdout
	f=file('out_new.txt','w')
	sys.stdout=f

	#print path
	start = time.asctime(time.localtime(time.time()))
	print("Start Time : "+start)
	main()
	end = time.asctime(time.localtime(time.time()))
	print("End Time : "+end)
	#print(str(time.time() - start)
